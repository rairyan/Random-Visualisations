# -*- coding: utf-8 -*-
"""Predator-Prey.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YqAmfm7EpX_DJX2VyeKXRTivxvmPxQpG
"""

#ChatGPT Generated

import subprocess
import sys

# Define the list of required packages

required_packages = [
    'numpy',
    'matplotlib',
    'scipy'
]

# Function to check if a package is installed

def is_package_installed(package):
    try:
        __import__(package)
        return True
    except ImportError:
        return False

# Function to install packages

def install_packages(packages):
    for package in packages:
        if not is_package_installed(package):
            print(f"Installing {package}...")
            subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])
        else:
            continue

# Install missing packages

install_packages(required_packages)

# import packages

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

# Define the Lotka-Volterra equations

def lotka_volterra(y, t, a, b, c, d):
    prey, predator = y
    dydt = [a * prey - b * prey * predator, d * prey * predator - c * predator]
    return dydt

# Define input function that handles erreurs

def get_input(prompt, type_=int, min_=None, max_=None):
    while True:
        try:
            value = type_(input(prompt))
            if (min_ is not None and value < min_) or (max_ is not None and value > max_):
                raise ValueError(f"Value must be between {min_} and {max_}.")
            return value
        except ValueError as e:
            print(f"Invalid input: {e}. Please try again.")

# Some initial conditions if you dk : 80 prey, 20 predator

prey_initial = get_input("How many prey do you want to start with (e.g. 80) ? ", int, 0)
predator_initial = get_input("How many predators do you want to start with (e.g. 20) ? ", int, 0)

initial_conditions = [prey_initial, predator_initial]

# Generate timepoints
t = np.linspace(0, 200, 1000)

# Parameters: a (prey birth rate), b (predation rate), c (predator death rate), d (reproduction rate of predators per prey eaten)
a = 0.1  # Prey birth rate
b = 0.002  # Predation rate
c = 0.2  # Predator death rate
d = 0.0025  # Reproduction rate of predators per prey eaten

# Solve the ODEs without any spike
solution_no_spike = odeint(lotka_volterra, initial_conditions, t, args=(a, b, c, d))

# Ask if the user wants to introduce a spike
introduce_spike = input("Do you want to introduce a spike? (y/n) ").strip().lower()

if introduce_spike == 'y':
    # Time point to introduce the spike
    spike_time = get_input("When did the spike occur ? (t < 200) (e.g. 100) ", int, 0, 200)

    # Split the time array into before and after the spike
    t_before_spike = t[t <= spike_time]
    t_after_spike = t[t > spike_time]

    # Solve the ODEs up to the spike
    solution_before_spike = odeint(lotka_volterra, initial_conditions, t_before_spike, args=(a, b, c, d))

    # Get changes in prey and predator populations (multiplicative factors)
    prey_multiplier = get_input("What is the change in prey (multiplier e.g. 0.2) ? ", float, 0.0)
    predator_multiplier = get_input("What is the change in predator (multiplier e.g. 1.2) ? ", float, 0.0)

    # Introduce a random spike in the prey and predator populations at t = spike_time
    prey_spike = solution_before_spike[-1, 0] * prey_multiplier
    predator_spike = solution_before_spike[-1, 1] * predator_multiplier

    # Calculate the change in prey and predator populations
    change_prey = prey_spike - solution_before_spike[-1, 0]
    change_predator = predator_spike - solution_before_spike[-1, 1]

    # Initial conditions after the spike
    initial_conditions_after_spike = [prey_spike, predator_spike]

    # Solve the ODEs after the spike
    solution_after_spike = odeint(lotka_volterra, initial_conditions_after_spike, t_after_spike, args=(a, b, c, d))

    # Combine the solutions
    t_combined = np.concatenate((t_before_spike, t_after_spike))
    solution_combined = np.vstack((solution_before_spike, solution_after_spike))

    # Plot the results
    prey_with_spike, predator_with_spike = solution_combined.T
    plt.plot(t_combined, prey_with_spike, label='Prey with Spike', color="deeppink")
    plt.plot(t_combined, predator_with_spike, label='Predators with Spike', color="darkviolet")
    plt.axvline(x=spike_time, color='black', linestyle='--', label=f'Spike at t = {spike_time}')
    plt.title(f'Lotka-Volterra Predator-Prey Model \n with '
              f'{"+" if change_prey >= 0 else ""}{change_prey:.0f} Prey '
              f'{"+" if change_predator >= 0 else ""}{change_predator:.0f} Predator '
              f'at t = {spike_time}')

    # Plot the results without spike (in dotted line)
    plt.plot(t, solution_no_spike[:, 0], label='Prey without Spike', color="salmon", linestyle=':')
    plt.plot(t, solution_no_spike[:, 1], label='Predators without Spike', color="violet", linestyle=':')

else:
    # No spike introduced, only plot the solution without spike
    plt.plot(t, solution_no_spike[:, 0], label='Prey without Spike', color="deeppink")
    plt.plot(t, solution_no_spike[:, 1], label='Predators without Spike', color="darkviolet")
    plt.title('Lotka-Volterra Predator-Prey Model without Spike')

plt.text(0.01, 0.01, "Seow Ryan", ha='left', va='bottom', transform=plt.gca().transAxes, fontsize=10, color='gainsboro')
plt.xlabel('Time')
plt.ylabel('Population')
plt.legend()
plt.show()

